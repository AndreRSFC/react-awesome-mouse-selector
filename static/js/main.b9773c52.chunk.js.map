{"version":3,"sources":["../../src/index.tsx","App.tsx","index.tsx"],"names":["getOffset","props","offset","top","left","boundingBox","window","Selection","bind","reset","init","Target","e","s","indexOf","call","nextState","mouseDown","startPoint","x","y","zoom","onMouseDown","onTouchStart","onMouseUp","endPoint","selectionBox","onMouseMove","onTouchMove","lineIntersects","lineA","lineB","boxIntersects","boxAProjection","boxA","boxBProjection","boxB","updateCollidingChildren","refBox","ref","tmpBox","width","height","clientHeight","JSON","onHighlightChange","calculateSelectionBox","startWidthCalc","Math","endWidthCalc","startHeightCalc","endHeightCalc","approximateLeftWidth","approximateRightWidth","approximateTopHeight","approximateBottomHeight","maxLeft","maxTop","item","checkInterception","getDerivedStateFromProps","nextProps","componentDidMount","this","componentDidUpdate","state","prevProps","setState","componentWillUnmount","render","style","React","className","cellSize","dataContent","PureComponent","App","useState","elRefs","setElRefs","currentRef","setCurrentRef","addElementRef","includes","elRefsLet","push","display","maxWidth","flexWrap","Array","fill","map","_","index","minWidth","minHeight","boxSizing","border","backgroundColor","target","elements","onSelectionChange","console","log","blockSelection","selectionSize","maxHeight","blockedPoints","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.b9773c52.chunk.js","sourcesContent":["import React from 'react'\n\nexport type Point = {\n  x: number\n  y: number\n}\n\nexport type Box = {\n  left: number\n  top: number\n  width: number\n  height: number\n}\n\ntype Props = {\n  disabled?: boolean\n  target: HTMLElement\n  onSelectionChange?: (elements: Array<number>) => void\n  onHighlightChange?: (elements: Array<number>) => void\n  elements: Array<HTMLElement>\n  offset?: {\n    top: number\n    left: number\n  }\n  style?: string\n  zoom?: number\n  ignoreTargets?: Array<string>\n  blockSelection?: boolean\n  cellSize: {\n    width: number\n    height: number\n  }\n  dataContent: string\n  selectionSize: {\n    maxWidth: number\n    maxHeight: number\n  }\n  blockedPoints: { left: number; top: number }[]\n}\n\ntype State = {\n  mouseDown: boolean\n  startPoint: Point | null\n  endPoint: Point | null\n  selectionBox: Box | null\n  offset: {\n    top: number\n    left: number\n  }\n  zoom: number\n}\n\nconst twoButton = 2\n\nfunction getOffset(props: Props) {\n  let offset = {\n    top: 0,\n    left: 0\n  }\n  if (props.offset) {\n    offset = {\n      ...props.offset\n    }\n  } else if (props.target) {\n    const boundingBox = props.target.getBoundingClientRect()\n\n    offset.top = boundingBox.top + window.scrollY\n    offset.left = boundingBox.left + window.scrollX\n  }\n  return offset\n}\n\nexport default class Selection extends React.PureComponent<Props, State> {\n  // eslint-disable-line react/prefer-stateless-function\n  props: Props\n  state: State\n  selectedChildren: Array<number>\n  highlightedChildren: Array<number>\n\n  constructor(props: Props) {\n    super(props)\n\n    this.state = {\n      mouseDown: false,\n      startPoint: null,\n      endPoint: null,\n      selectionBox: null,\n      offset: getOffset(props),\n      zoom: props.zoom || 1\n    }\n\n    this.selectedChildren = []\n    this.highlightedChildren = []\n  }\n\n  static getDerivedStateFromProps(nextProps: Props) {\n    return {\n      offset: getOffset(nextProps)\n    }\n  }\n\n  componentDidMount() {\n    this.reset()\n    this.bind()\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    this.reset()\n    this.bind()\n\n    if (this.state.mouseDown && this.state.selectionBox) {\n      this.updateCollidingChildren(this.state.selectionBox)\n    }\n\n    if (prevProps.blockSelection !== this.props.blockSelection) {\n      !this.props.blockSelection &&\n        this.setState({\n          mouseDown: false,\n          startPoint: null,\n          endPoint: null,\n          selectionBox: null\n        })\n    }\n  }\n\n  componentWillUnmount() {\n    this.reset()\n    window.document.removeEventListener('mousemove', this.onMouseMove)\n    window.document.removeEventListener('mouseup', this.onMouseUp)\n  }\n\n  bind = () => {\n    this.props.target.addEventListener('mousedown', this.onMouseDown)\n    this.props.target.addEventListener('touchstart', this.onTouchStart)\n  }\n\n  reset = () => {\n    if (this.props.target) {\n      this.props.target.removeEventListener('mousedown', this.onMouseDown)\n    }\n  }\n\n  init = (e: { target: any }, x: number, y: number): boolean => {\n    if (this.props.ignoreTargets) {\n      const Target = e.target\n      if (!Target.matches) {\n        // polyfill matches\n        const defaultMatches = (s: string) =>\n          [].indexOf.call(window.document.querySelectorAll(s), this) !== -1\n        Target.matches =\n          Target.matchesSelector ||\n          Target.mozMatchesSelector ||\n          Target.msMatchesSelector ||\n          Target.oMatchesSelector ||\n          Target.webkitMatchesSelector ||\n          defaultMatches\n      }\n      if (\n        Target.matches &&\n        Target.matches(this.props.ignoreTargets.join(','))\n      ) {\n        return false\n      }\n    }\n\n    const startPoint = {\n      x: (x - this.state.offset.left) / this.state.zoom,\n      y: (y - this.state.offset.top) / this.state.zoom\n    }\n\n    const nextState = { mouseDown: true, startPoint: startPoint }\n\n    this.setState(nextState)\n    return true\n  }\n\n  /**\n   * On root element mouse down\n   * The event should be a MouseEvent | TouchEvent, but flow won't get it...\n   * @private\n   */\n  onMouseDown = (e: MouseEvent | any) => {\n    if (\n      this.props.disabled ||\n      e.button === twoButton ||\n      (e.nativeEvent && e.nativeEvent.which === twoButton)\n    ) {\n      return\n    }\n\n    if (this.init(e, e.pageX, e.pageY)) {\n      window.document.addEventListener('mousemove', this.onMouseMove)\n      window.document.addEventListener('mouseup', this.onMouseUp)\n    }\n  }\n\n  onTouchStart = (e: TouchEvent) => {\n    if (\n      this.props.disabled ||\n      !e.touches ||\n      !e.touches[0] ||\n      e.touches.length > 1\n    ) {\n      return\n    }\n\n    if (this.init(e, e.touches[0].pageX, e.touches[0].pageY)) {\n      window.document.addEventListener('touchmove', this.onTouchMove)\n      window.document.addEventListener('touchend', this.onMouseUp)\n    }\n  }\n\n  /**\n   * On document element mouse up\n   * @private\n   */\n  onMouseUp = () => {\n    window.document.removeEventListener('touchmove', this.onTouchMove)\n    window.document.removeEventListener('mousemove', this.onMouseMove)\n    window.document.removeEventListener('mouseup', this.onMouseUp)\n    window.document.removeEventListener('touchend', this.onMouseUp)\n\n    !this.props.blockSelection &&\n      this.setState({\n        mouseDown: false,\n        startPoint: null,\n        endPoint: null,\n        selectionBox: null\n      })\n\n    if (this.props.onSelectionChange) {\n      this.props.onSelectionChange(this.selectedChildren)\n    }\n\n    if (this.props.onHighlightChange) {\n      this.highlightedChildren = []\n      this.props.onHighlightChange(this.highlightedChildren)\n    }\n    this.selectedChildren = []\n  }\n\n  /**\n   * On document element mouse move\n   * @private\n   */\n  onMouseMove = (e: MouseEvent) => {\n    e.preventDefault()\n    if (this.state.mouseDown) {\n      const endPoint: Point = {\n        x: (e.pageX - this.state.offset.left) / this.state.zoom,\n        y: (e.pageY - this.state.offset.top) / this.state.zoom\n      }\n\n      this.setState({\n        endPoint,\n        selectionBox:\n          this.state.startPoint &&\n          this.calculateSelectionBox(this.state.startPoint, endPoint)\n      })\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    e.preventDefault()\n    if (this.state.mouseDown) {\n      const endPoint: Point = {\n        x: (e.touches[0].pageX - this.state.offset.left) / this.state.zoom,\n        y: (e.touches[0].pageY - this.state.offset.top) / this.state.zoom\n      }\n\n      this.setState({\n        endPoint,\n        selectionBox:\n          this.state.startPoint &&\n          this.calculateSelectionBox(this.state.startPoint, endPoint)\n      })\n    }\n  }\n\n  /**\n   * Calculate if two segments overlap in 1D\n   * @param lineA [min, max]\n   * @param lineB [min, max]\n   */\n  lineIntersects = (lineA: number[], lineB: number[]): boolean =>\n    lineA[1] >= lineB[0] && lineB[1] >= lineA[0]\n\n  /**\n   * Detect twoButtonD box intersection - the two boxes will intersect\n   * if their projections to both axis overlap\n   * @private\n   */\n  boxIntersects = (boxA: Box, boxB: Box): boolean => {\n    // calculate coordinates of all points\n    const boxAProjection = {\n      x: [boxA.left, boxA.left + boxA.width],\n      y: [boxA.top, boxA.top + boxA.height]\n    }\n\n    const boxBProjection = {\n      x: [boxB.left, boxB.left + boxB.width],\n      y: [boxB.top, boxB.top + boxB.height]\n    }\n\n    return (\n      this.lineIntersects(boxAProjection.x, boxBProjection.x) &&\n      this.lineIntersects(boxAProjection.y, boxBProjection.y)\n    )\n  }\n\n  /**\n   * Updates the selected items based on the\n   * collisions with selectionBox,\n   * also updates the highlighted items if they have changed\n   * @private\n   */\n  updateCollidingChildren = (selectionBox: Box) => {\n    this.selectedChildren = []\n    if (this.props.elements) {\n      this.props.elements.forEach((ref, $index) => {\n        if (ref) {\n          const refBox = ref.getBoundingClientRect()\n          const tmpBox = {\n            top:\n              (refBox.top - this.state.offset.top + window.scrollY) /\n              this.state.zoom,\n            left:\n              (refBox.left - this.state.offset.left + window.scrollX) /\n              this.state.zoom,\n            width: ref.clientWidth,\n            height: ref.clientHeight\n          }\n\n          if (this.boxIntersects(selectionBox, tmpBox)) {\n            this.selectedChildren.push($index)\n          }\n        }\n      })\n    }\n    if (\n      this.props.onHighlightChange &&\n      JSON.stringify(this.highlightedChildren) !==\n        JSON.stringify(this.selectedChildren)\n    ) {\n      const { onHighlightChange } = this.props\n      this.highlightedChildren = [...this.selectedChildren]\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(() => {\n          onHighlightChange(this.highlightedChildren)\n        })\n      } else {\n        onHighlightChange(this.highlightedChildren)\n      }\n    }\n  }\n\n  /**\n   * Calculate selection box dimensions\n   * @private\n   */\n  calculateSelectionBox = (startPoint: Point, endPoint: Point) => {\n    if (!this.state.mouseDown || !startPoint || !endPoint) {\n      return null\n    }\n\n    const startWidthCalc = Math.floor(startPoint.x / this.props.cellSize.width)\n    const endWidthCalc = Math.floor(endPoint.x / this.props.cellSize.width)\n\n    const startHeightCalc = Math.floor(\n      startPoint.y / this.props.cellSize.height\n    )\n    const endHeightCalc = Math.floor(endPoint.y / this.props.cellSize.height)\n\n    const approximateLeftWidth =\n      Math.abs(\n        (startWidthCalc + 1) * this.props.cellSize.width -\n          endWidthCalc * this.props.cellSize.width\n      ) - twoButton\n\n    const approximateRightWidth =\n      Math.abs(\n        startWidthCalc * this.props.cellSize.width -\n          (endWidthCalc + 1) * this.props.cellSize.width\n      ) - twoButton\n\n    const approximateTopHeight =\n      Math.abs(\n        (startHeightCalc + 1) * this.props.cellSize.height -\n          endHeightCalc * this.props.cellSize.height\n      ) - twoButton\n\n    const approximateBottomHeight =\n      Math.abs(\n        startHeightCalc * this.props.cellSize.height -\n          (endHeightCalc + 1) * this.props.cellSize.height\n      ) - twoButton\n\n    // This calculation is based on the cell size to better meet the table\n\n    const left = Math.min(\n      startWidthCalc * this.props.cellSize.width,\n      endWidthCalc * this.props.cellSize.width\n    )\n\n    const top = Math.min(\n      startHeightCalc * this.props.cellSize.height,\n      endHeightCalc * this.props.cellSize.height\n    )\n\n    const maxLeft = Math.max(\n      startWidthCalc * this.props.cellSize.width,\n      endWidthCalc * this.props.cellSize.width\n    )\n\n    const maxTop = Math.max(\n      startHeightCalc * this.props.cellSize.height,\n      endHeightCalc * this.props.cellSize.height\n    )\n\n    if (\n      top >= 0 &&\n      left >= 0 &&\n      maxTop <= this.props.selectionSize.maxHeight &&\n      maxLeft <= this.props.selectionSize.maxWidth\n    ) {\n      const width =\n        startWidthCalc * this.props.cellSize.width >\n        endWidthCalc * this.props.cellSize.width\n          ? approximateLeftWidth\n          : approximateRightWidth\n\n      const height =\n        startHeightCalc * this.props.cellSize.height >\n        endHeightCalc * this.props.cellSize.height\n          ? approximateTopHeight\n          : approximateBottomHeight\n\n      const checkInterception = this.props.blockedPoints.filter(\n        (item) =>\n          (top === item.top && left === item.left) ||\n          (top + height - this.props.cellSize.height + twoButton === item.top &&\n            left + width - this.props.cellSize.width + twoButton === item.left)\n      )\n\n      if (checkInterception.length === 0) {\n        return {\n          left,\n          top,\n          width,\n          height\n        }\n      }\n\n      return this.state.selectionBox\n    } else {\n      return this.state.selectionBox\n    }\n  }\n\n  /**\n   * Render\n   */\n  render() {\n    let style\n\n    if (this.state.selectionBox) {\n      style = this.state.selectionBox\n    }\n\n    if (\n      !this.state.mouseDown ||\n      !this.state.endPoint ||\n      !this.state.startPoint\n    ) {\n      return null\n    }\n\n    return (\n      <div\n        className={`react-ds-border ${this.props.style}`}\n        style={style}\n        {...(this.state.selectionBox &&\n        this.state.selectionBox.width + twoButton >=\n          this.props.cellSize.width &&\n        this.state.selectionBox.width + twoButton >= this.props.cellSize.width\n          ? { 'data-content': this.props.dataContent }\n          : {})}\n      />\n    )\n  }\n}\n","import React, { useState } from 'react'\n\nimport Selection from 'react-awesome-mouse-selector'\n// import 'react-awesome-mouse-selector/dist/index.css'\n\nimport './index.css'\n\nconst App = () => {\n  const [elRefs, setElRefs] = useState<HTMLDivElement[]>([])\n  const [currentRef, setCurrentRef] = useState<HTMLDivElement>()\n\n  const addElementRef = (ref: any) => {\n    if (!elRefs.includes(ref)) {\n      const elRefsLet = elRefs\n      elRefsLet.push(ref)\n      setElRefs(elRefsLet)\n    }\n  }\n\n  const renderSelection = () => {\n    if (!currentRef || !elRefs) {\n      return null\n    }\n\n    return (\n      <Selection\n        target={currentRef}\n        elements={elRefs}\n        onSelectionChange={(e) => console.log(e)}\n        onHighlightChange={(e) => console.log(e)}\n        style='block'\n        dataContent={''}\n        blockSelection={false}\n        cellSize={{ width: 141, height: 98 }}\n        selectionSize={{ maxWidth: 422, maxHeight: 293 }}\n        blockedPoints={[]}\n      />\n    )\n  }\n\n  return (\n    <div\n      ref={(ref) => {\n        ref && setCurrentRef(ref)\n      }}\n      style={{ display: 'flex', maxWidth: '423px', flexWrap: 'wrap' }}\n    >\n      {Array(9)\n        .fill(null)\n        .map((_, index) => {\n          return (\n            <div\n              ref={addElementRef}\n              style={{\n                minWidth: '141px',\n                minHeight: '98px',\n                boxSizing: 'border-box',\n                border: '1px solid  black',\n                backgroundColor: 'red'\n              }}\n            >\n              {index}\n            </div>\n          )\n        })}\n      {renderSelection()}\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}